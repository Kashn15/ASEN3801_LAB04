%% ASEN 3801 | Lab 04 Task 1 ODE Function
% Creators:
% Assignment Due Date:
% Purpose:
% (1) Determine trim Thrust for rotors in steady hovering flight
% (2) Simulate this trim state for 10 seconds and verify that it produces
% equilibrium motion.

clc;
clear;
close all;

% Load Data
RSdata = load('RSdata_nocontrol.mat');

% Initialization
t = 10; % Period [s]
fig = [101, 102, 103, 104, 105, 106];
col = ['--b','--r','--g'];

motor_forces = zeros(4, 1); % Initialize motor forces vector

% Givens
m=0.068; % kg
g=9.81; % m/s^2
I=diag([5.8e-5 7.2e-5 1.0e-4]); % kg*m^2
km=0.0024; % N*m/(N)
vu = 1e-3; % N/m/s)^2
mu = 2e-6; % N*m/(rad/s)^2
d = 0.060; % m

% Hover Conditioning
fi = m*g/4; % Zc = -(f1+f2+f3+f4) = -m*g
motor_forces_hover = fi * ones(4,1);

% Establishing State Vector
x_e = 0;
y_e = 0;
z_e = 0;
psi = 0;
theta = 0;
phi = 0;
u_e = 0;
v_e = 0;
w_e = 0;
p = 0;
q = 0;
r = 0;

var = [x_e; y_e; z_e; psi; theta; phi; u_e; v_e; w_e; p; q; r];

% ODE function run
odefun = @(t,x) QuadrotorEOM(t, x, g, m, I, d, km, vu, mu, motor_forces_hover);
[t, X] = ode45(odefun, [0, t], var);

PlotAircraftSim(t,X,motor_forces_hover,[1,2,3,4,5,6],'b')


%% Functions

% Rotation Matrix
function R_EB = Rot_Mat(psi, theta, phi)

R1 = [cos(theta)*cos(phi), sin(psi)*sin(theta)*cos(phi)-cos(psi)*sin(phi), cos(psi)*sin(theta)*cos(phi)+sin(psi)*sin(phi)];
R2 = [cos(theta)*sin(phi), sin(psi)*sin(theta)*sin(phi)+cos(psi)*cos(phi), cos(psi)*sin(theta)*sin(phi)-sin(psi)*cos(phi)];
R3 = [-sin(theta), sin(psi)*cos(theta), cos(psi)*cos(theta)];

R_EB = [R1; R2; R3];

end

% Rotational Kinematics
function eul_dot = euler_kinematics(psi, theta, phi, pqr)
p = pqr(1); 
q = pqr(2); 
r = pqr(3);
 
cphi = cos(phi); 
sphi = sin(phi);
cth  = cos(theta); 
sth = sin(theta);

T = [ 1, sphi*sth/cth, cphi*sth/cth;   % = [1, sin(phi)*tan(theta), cos(phi)*tan(theta)]
      0, cphi, -sphi;
      0, sphi/cth, cphi/cth];

eul_dot = T * [p; q; r];

end

% Motor Forces
function motor_forces = MotorForces(Fc, Gc, d, km)
Zc = Fc(3);
Lc = Gc(1); 
Mc = Gc(2); 
Nc = Gc(3);

A = [-1, -1, -1, -1;
     -d/sqrt(2), -d/sqrt(2), d/sqrt(2), d/sqrt(2);
      d/sqrt(2), -d/sqrt(2), -d/sqrt(2), d/sqrt(2);
      km, -km, km, -km];

b = [Zc; Lc; Mc; Nc];

motor_forces = A \ b; % 4x1

end                  

% ODE
function var_dot = QuadrotorEOM(t, var, g, m, I, d, km, vu, mu, motor_forces)

%State Vector
x = var(1); 
y = var(2); 
z = var(3);
psi = var(4); 
theta = var(5); 
phi = var(6);
u = var(7); 
v = var(8); 
w = var(9);
p = var(10); 
q = var(11); 
r = var(12);

% Aerodynamics
F_aero = -vu * [u*abs(u); v*abs(v); w*abs(w)]; % N
M_aero = -mu * [p*abs(p); q*abs(q); r*abs(r)]; % N*m

% Rotation matrices
R_EB = Rot_Mat(psi,theta,phi);    % body -> earth
R_BE = R_EB.';                    % earth -> body

omega = [p;q;r];
Vb = [u;v;w];

% Motor
f = motor_forces(:);
Zc = -(f(1)+f(2)+f(3)+f(4));
Lc = d/sqrt(2) * (-f(1) - f(2) + f(3) + f(4));
Mc = d/sqrt(2) * ( f(1) - f(2) - f(3) + f(4));
Nc = km * ( f(1) - f(2) + f(3) - f(4));

% Forces and Moments
F_thrust = [0; 0; Zc];                 % rotor resultant along body z
F_g = m * (R_BE * [0;0;g]);       % gravity expressed in body
F_tot = F_thrust + F_g + F_aero;
M_tot = [Lc; Mc; Nc] + M_aero;

% Kinematics
posit_dot = R_EB * Vb;
eul_dot = euler_kinematics(psi,theta,phi,[p;q;r]);

% Dynamics
uvw_dot  = (F_tot - cross(omega, m*Vb)) / m;
pqr_dot  = I \ (M_tot - cross(omega, I*omega)); % Cross() is MatLab's cross function


var_dot = [posit_dot; uvw_dot; eul_dot;pqr_dot]

end

%Quadrotor EOM Linearized
function var_dot = QuadrotorEOM_Linearized(t, var, g, m, I, deltaFc, deltaGc)
%State Vector
x = var(1); y = var(2); z = var(3);
phi = var(4); theta = var(5); psi = var(6);
u = var(7); v = var(8); w = var(9);
p = var(10); q = var(11); r = var(12);

%Derivatives
x_dot = u; y_dot = v; z_dot = w;
phi_dot = p; theta_dot = q; psi_dot = r;
u_dot = -g*theta; v_dot = g*phi; w_dot = deltaFc*(1/m);
p_dot = (1/I(1))*deltaGc(1); q_dot = (1/I(2))*deltaGc(2); r_dot = (1/I(3))*deltaGc(3);

var_dot = [x_dot,y_dot,z_dot;phi_dot,theta_dot,psi_dot;u_dot,v_dot,w_dot;p_dot,q_dot,r_dot];

end

%Plot function
function PlotAircraftSim(time, aircraft_state_array, control_input_array,fig, col)
Inertial_pos = aircraft_state_array(:,1:3);
Euler_angles = aircraft_state_array(:,4:6);
Inertial_velo = aircraft_state_array(:,7:9);
Angular_velo = aircraft_state_array(:,10:12);

%Plot inertial positions
figure(fig(1))
subplot(3,1,1)
plot(time,Inertial_pos(:,1),col); hold on;
xlabel('Time')
ylabel('x (m)')
subplot(3,1,2)
plot(time,Inertial_pos(:,2),col); hold on;
xlabel('Time')
ylabel('y (m)')
subplot(3,1,3)
plot(time,Inertial_pos(:,3),col); hold on;
xlabel('Time')
ylabel('z (m)')

%Plot Euler Angles
figure(fig(2))
subplot(3,1,1)
plot(time,Euler_angles(:,1),col); hold on;
xlabel('Time')
ylabel('Phi (rad)')
subplot(3,1,2)
plot(time,Euler_angles(:,2),col); hold on;
xlabel('Time')
ylabel('Theta (rad)')
subplot(3,1,3)
plot(time,Euler_angles(:,3),col); hold on;
xlabel('Time')
ylabel('Psi (rad)')

%Plot inertial velocity
figure(fig(3))
subplot(3,1,1)
plot(time,Inertial_velo(:,1),col); hold on;
xlabel('Time')
ylabel('u (m/s)')
subplot(3,1,2)
plot(time,Inertial_velo(:,2),col); hold on;
xlabel('Time')
ylabel('v (m/s)')
subplot(3,1,3)
plot(time,Inertial_velo(:,3),col); hold on;
xlabel('Time')
ylabel('w (m/s)')

%Plot angular velo
figure(fig(4))
subplot(3,1,1)
plot(time,Angular_velo(:,1),col); hold on;
xlabel('Time')
ylabel('p (rad/s)')
subplot(3,1,2)
plot(time,Angular_velo(:,2),col); hold on;
xlabel('Time')
ylabel('q (rad/s)')
subplot(3,1,3)
plot(time,Angular_velo(:,3),col); hold on;
xlabel('Time')
ylabel('r (rad/s)')

%Plot control variables
figure(fig(5))
subplot(4,1,1)
plot(time,control_input_array(:,1),col); hold on;
xlabel('Time')
ylabel('Zc (N)')
subplot(4,1,2)
plot(time,control_input_array(:,2),col); hold on;
xlabel('Time')
ylabel('Lc (N)')
subplot(4,1,3)
plot(time,control_input_array(:,3),col); hold on;
xlabel('Time')
ylabel('Mc (N)')
subplot(4,1,4)
plot(time,control_input_array(:,4),col); hold on;
xlabel('Time')
ylabel('Nc (N)')

%3D Plot of Aircraft Position
figure(fig(6))
plot3(Inertial_pos(:,1), Inertial_pos(:,2), -Inertial_pos(:,3), col); hold on;%Negative z to make positive up
grid on;
xlabel('X (m)');
ylabel('Y (m)');
zlabel('Z (m)');
%Begin and end circles
plot3(Inertial_pos(1,1), Inertial_pos(1,2), -Inertial_pos(1,3),'g')
plot3(Inertial_pos(1,end), Inertial_pos(2,end), -Inertial_pos(3,end),'r')
end
